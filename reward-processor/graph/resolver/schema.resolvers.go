package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.74

import (
	"context"
	"fmt"

	"github.com/alexandredsa/learning-rewards/reward-processor/graph/generated"
	"github.com/alexandredsa/learning-rewards/reward-processor/graph/model"
	"go.uber.org/zap"
)

// CreateRule is the resolver for the createRule field.
func (r *mutationResolver) CreateRule(ctx context.Context, input model.CreateRuleInput) (*model.Rule, error) {
	r.Logger.Debug("Creating new rule",
		zap.String("eventType", input.EventType),
		zap.Any("input", input))

	rule := ConvertGraphQLRuleToModel(&input)
	if err := r.RuleRepository.CreateRule(ctx, rule); err != nil {
		r.Logger.Debug("Failed to create rule in repository",
			zap.Any("rule", rule),
			zap.Error(err))
		return nil, fmt.Errorf("failed to create rule: %w", err)
	}

	r.Logger.Debug("Successfully created rule",
		zap.String("ruleID", rule.ID))
	return ConvertToGraphQLRule(rule), nil
}

// UpdateRule is the resolver for the updateRule field.
func (r *mutationResolver) UpdateRule(ctx context.Context, id string, input model.UpdateRuleInput) (*model.Rule, error) {
	r.Logger.Debug("Updating rule",
		zap.String("ruleID", id),
		zap.Any("input", input))

	// First get the existing rule to update
	existingRule, err := r.RuleRepository.GetRuleByID(ctx, id)
	if err != nil {
		r.Logger.Debug("Failed to fetch existing rule",
			zap.String("ruleID", id),
			zap.Error(err))
		return nil, fmt.Errorf("failed to fetch rule: %w", err)
	}
	if existingRule == nil {
		r.Logger.Debug("Rule not found",
			zap.String("ruleID", id))
		return nil, fmt.Errorf("rule not found: %s", id)
	}

	// Apply updates
	updates := ConvertGraphQLRuleToModel(&input)
	if updates.EventType != "" {
		existingRule.EventType = updates.EventType
	}
	if updates.Count > 0 {
		existingRule.Count = updates.Count
	}
	if updates.Conditions != nil {
		existingRule.Conditions = updates.Conditions
	}
	if updates.Reward.Type != "" {
		existingRule.Reward.Type = updates.Reward.Type
	}
	if updates.Reward.Amount > 0 {
		existingRule.Reward.Amount = updates.Reward.Amount
	}
	if updates.Reward.Description != "" {
		existingRule.Reward.Description = updates.Reward.Description
	}
	if updates.Enabled {
		existingRule.Enabled = updates.Enabled
	}

	if err := r.RuleRepository.UpdateRule(ctx, id, existingRule); err != nil {
		r.Logger.Debug("Failed to update rule in repository",
			zap.String("ruleID", id),
			zap.Any("updatedRule", existingRule),
			zap.Error(err))
		return nil, fmt.Errorf("failed to update rule: %w", err)
	}

	// Fetch the updated rule to return the complete state
	finalRule, err := r.RuleRepository.GetRuleByID(ctx, id)
	if err != nil {
		r.Logger.Debug("Failed to fetch updated rule",
			zap.String("ruleID", id),
			zap.Error(err))
		return nil, fmt.Errorf("failed to fetch updated rule: %w", err)
	}

	r.Logger.Debug("Successfully updated rule",
		zap.String("ruleID", id))
	return ConvertToGraphQLRule(finalRule), nil
}

// Rules is the resolver for the rules field.
func (r *queryResolver) Rules(ctx context.Context) ([]*model.Rule, error) {
	rules, err := r.RuleRepository.GetEnabledRules(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch rules: %w", err)
	}

	result := make([]*model.Rule, len(rules))
	for i, rule := range rules {
		result[i] = ConvertToGraphQLRule(&rule)
	}
	return result, nil
}

// Rule is the resolver for the rule field.
func (r *queryResolver) Rule(ctx context.Context, id string) (*model.Rule, error) {
	rule, err := r.RuleRepository.GetRuleByID(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch rule: %w", err)
	}
	if rule == nil {
		return nil, nil
	}
	return ConvertToGraphQLRule(rule), nil
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }

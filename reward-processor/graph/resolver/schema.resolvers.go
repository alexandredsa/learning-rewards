package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.74

import (
	"context"
	"encoding/json"
	"fmt"

	"github.com/alexandredsa/learning-rewards/reward-processor/graph/generated"
	"github.com/alexandredsa/learning-rewards/reward-processor/graph/model"
	"github.com/alexandredsa/learning-rewards/reward-processor/pkg/models"
)

// CreateRule is the resolver for the createRule field.
func (r *mutationResolver) CreateRule(ctx context.Context, input model.CreateRuleInput) (*model.Rule, error) {
	// Convert conditions from JSON string to map
	var conditions models.RuleConditions
	if err := json.Unmarshal([]byte(input.Conditions), &conditions); err != nil {
		return nil, fmt.Errorf("invalid conditions format: %w", err)
	}

	// Convert count from pointer to value
	count := 0
	if input.Count != nil {
		count = *input.Count
	}

	// Convert reward amount from pointer to value
	rewardAmount := 0
	if input.Reward.Amount != nil {
		rewardAmount = *input.Reward.Amount
	}

	rule := &models.Rule{
		Type:       models.RuleType(input.Type),
		EventType:  input.EventType,
		Count:      count,
		Conditions: conditions,
		Reward: models.Reward{
			Type:        models.RewardType(input.Reward.Type),
			Amount:      rewardAmount,
			Description: input.Reward.Description,
		},
		Enabled: input.Enabled,
	}

	if err := r.RuleRepository.CreateRule(ctx, rule); err != nil {
		return nil, fmt.Errorf("failed to create rule: %w", err)
	}

	return convertToGraphQLRule(rule), nil
}

// UpdateRule is the resolver for the updateRule field.
func (r *mutationResolver) UpdateRule(ctx context.Context, id string, input model.UpdateRuleInput) (*model.Rule, error) {
	// First get the existing rule to update
	existingRule, err := r.RuleRepository.GetRuleByID(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch rule: %w", err)
	}
	if existingRule == nil {
		return nil, fmt.Errorf("rule not found: %s", id)
	}

	// Update fields if provided
	if input.Type != nil {
		existingRule.Type = models.RuleType(*input.Type)
	}
	if input.EventType != nil {
		existingRule.EventType = *input.EventType
	}
	if input.Count != nil {
		existingRule.Count = *input.Count
	}
	if input.Conditions != nil {
		var conditions models.RuleConditions
		if err := json.Unmarshal([]byte(*input.Conditions), &conditions); err != nil {
			return nil, fmt.Errorf("invalid conditions format: %w", err)
		}
		existingRule.Conditions = conditions
	}
	if input.Reward != nil {
		if input.Reward.Type != "" {
			existingRule.Reward.Type = models.RewardType(input.Reward.Type)
		}
		if input.Reward.Amount != nil {
			existingRule.Reward.Amount = *input.Reward.Amount
		}
		if input.Reward.Description != "" {
			existingRule.Reward.Description = input.Reward.Description
		}
	}
	if input.Enabled != nil {
		existingRule.Enabled = *input.Enabled
	}

	if err := r.RuleRepository.UpdateRule(ctx, id, existingRule); err != nil {
		return nil, fmt.Errorf("failed to update rule: %w", err)
	}

	// Fetch the updated rule to return the complete state
	updatedRule, err := r.RuleRepository.GetRuleByID(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch updated rule: %w", err)
	}

	return convertToGraphQLRule(updatedRule), nil
}

// Rules is the resolver for the rules field.
func (r *queryResolver) Rules(ctx context.Context) ([]*model.Rule, error) {
	rules, err := r.RuleRepository.GetEnabledRules(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch rules: %w", err)
	}

	result := make([]*model.Rule, len(rules))
	for i, rule := range rules {
		result[i] = convertToGraphQLRule(&rule)
	}
	return result, nil
}

// Rule is the resolver for the rule field.
func (r *queryResolver) Rule(ctx context.Context, id string) (*model.Rule, error) {
	rule, err := r.RuleRepository.GetRuleByID(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch rule: %w", err)
	}
	if rule == nil {
		return nil, nil
	}
	return convertToGraphQLRule(rule), nil
}

// Helper function to convert from domain model to GraphQL model
func convertToGraphQLRule(rule *models.Rule) *model.Rule {
	// Convert conditions to JSON string
	conditionsJSON, _ := json.Marshal(rule.Conditions)

	// Convert count to pointer
	var countPtr *int
	if rule.Count > 0 {
		count := rule.Count
		countPtr = &count
	}

	// Convert reward amount to pointer
	var amountPtr *int
	if rule.Reward.Amount > 0 {
		amount := rule.Reward.Amount
		amountPtr = &amount
	}

	return &model.Rule{
		ID:         rule.ID,
		Type:       string(rule.Type),
		EventType:  rule.EventType,
		Count:      countPtr,
		Conditions: string(conditionsJSON),
		Reward: &model.Reward{
			Type:        string(rule.Reward.Type),
			Amount:      amountPtr,
			Description: rule.Reward.Description,
		},
		Enabled: rule.Enabled,
	}
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }

package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.74

import (
	"context"
	"encoding/json"
	"fmt"

	"github.com/alexandredsa/learning-rewards/reward-processor/graph/generated"
	"github.com/alexandredsa/learning-rewards/reward-processor/graph/model"
	"github.com/alexandredsa/learning-rewards/reward-processor/pkg/models"
	"go.uber.org/zap"
)

// CreateRule is the resolver for the createRule field.
func (r *mutationResolver) CreateRule(ctx context.Context, input model.CreateRuleInput) (*model.Rule, error) {
	r.Logger.Debug("Creating new rule",
		zap.String("eventType", input.EventType),
		zap.Any("input", input))

	// Convert conditions from JSON string to map
	var conditions models.RuleConditions
	if input.Conditions != nil && *input.Conditions != "" {
		if err := json.Unmarshal([]byte(*input.Conditions), &conditions); err != nil {
			r.Logger.Debug("Failed to unmarshal conditions",
				zap.String("conditions", *input.Conditions),
				zap.Error(err))
			return nil, fmt.Errorf("invalid conditions format: %w", err)
		}
	}

	// Convert count from pointer to value
	count := 0
	if input.Count != nil {
		count = *input.Count
	}

	// Convert reward amount from pointer to value
	rewardAmount := 0
	if input.Reward.Amount != nil {
		rewardAmount = *input.Reward.Amount
	}

	rule := &models.Rule{
		EventType:  input.EventType,
		Count:      count,
		Conditions: conditions,
		Reward: models.Reward{
			Type:        models.RewardType(input.Reward.Type),
			Amount:      rewardAmount,
			Description: input.Reward.Description,
		},
		Enabled: input.Enabled,
	}

	r.Logger.Debug("Attempting to create rule in repository",
		zap.Any("rule", rule))

	if err := r.RuleRepository.CreateRule(ctx, rule); err != nil {
		r.Logger.Debug("Failed to create rule in repository",
			zap.Any("rule", rule),
			zap.Error(err))
		return nil, fmt.Errorf("failed to create rule: %w", err)
	}

	r.Logger.Debug("Successfully created rule",
		zap.String("ruleID", rule.ID))
	return convertToGraphQLRule(rule), nil
}

// UpdateRule is the resolver for the updateRule field.
func (r *mutationResolver) UpdateRule(ctx context.Context, id string, input model.UpdateRuleInput) (*model.Rule, error) {
	r.Logger.Debug("Updating rule",
		zap.String("ruleID", id),
		zap.Any("input", input))

	// First get the existing rule to update
	existingRule, err := r.RuleRepository.GetRuleByID(ctx, id)
	if err != nil {
		r.Logger.Debug("Failed to fetch existing rule",
			zap.String("ruleID", id),
			zap.Error(err))
		return nil, fmt.Errorf("failed to fetch rule: %w", err)
	}
	if existingRule == nil {
		r.Logger.Debug("Rule not found",
			zap.String("ruleID", id))
		return nil, fmt.Errorf("rule not found: %s", id)
	}

	if input.EventType != nil {
		existingRule.EventType = *input.EventType
	}
	if input.Count != nil {
		existingRule.Count = *input.Count
	}
	if input.Conditions != nil {
		var conditions models.RuleConditions
		if *input.Conditions != "" {
			if err := json.Unmarshal([]byte(*input.Conditions), &conditions); err != nil {
				return nil, fmt.Errorf("invalid conditions format: %w", err)
			}
		}
		existingRule.Conditions = conditions
	}
	if input.Reward != nil {
		if input.Reward.Type != "" {
			existingRule.Reward.Type = models.RewardType(input.Reward.Type)
		}
		if input.Reward.Amount != nil {
			existingRule.Reward.Amount = *input.Reward.Amount
		}
		if input.Reward.Description != "" {
			existingRule.Reward.Description = input.Reward.Description
		}
	}
	if input.Enabled != nil {
		existingRule.Enabled = *input.Enabled
	}

	if err := r.RuleRepository.UpdateRule(ctx, id, existingRule); err != nil {
		r.Logger.Debug("Failed to update rule in repository",
			zap.String("ruleID", id),
			zap.Any("updatedRule", existingRule),
			zap.Error(err))
		return nil, fmt.Errorf("failed to update rule: %w", err)
	}

	// Fetch the updated rule to return the complete state
	updatedRule, err := r.RuleRepository.GetRuleByID(ctx, id)
	if err != nil {
		r.Logger.Debug("Failed to fetch updated rule",
			zap.String("ruleID", id),
			zap.Error(err))
		return nil, fmt.Errorf("failed to fetch updated rule: %w", err)
	}

	r.Logger.Debug("Successfully updated rule",
		zap.String("ruleID", id))
	return convertToGraphQLRule(updatedRule), nil
}

// Rules is the resolver for the rules field.
func (r *queryResolver) Rules(ctx context.Context) ([]*model.Rule, error) {
	rules, err := r.RuleRepository.GetEnabledRules(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch rules: %w", err)
	}

	result := make([]*model.Rule, len(rules))
	for i, rule := range rules {
		result[i] = convertToGraphQLRule(&rule)
	}
	return result, nil
}

// Rule is the resolver for the rule field.
func (r *queryResolver) Rule(ctx context.Context, id string) (*model.Rule, error) {
	rule, err := r.RuleRepository.GetRuleByID(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch rule: %w", err)
	}
	if rule == nil {
		return nil, nil
	}
	return convertToGraphQLRule(rule), nil
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }

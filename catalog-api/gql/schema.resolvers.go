package gql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.74

import (
	"catalog-api/internal/models"
	"context"

	"github.com/google/uuid"
)

func (r *queryResolver) Courses(ctx context.Context, ids []string) ([]*Course, error) {
	var courses []models.Course

	query := r.DB.Preload("Category")
	if len(ids) > 0 {
		var uuids []uuid.UUID
		for _, id := range ids {
			uid, err := uuid.Parse(id)
			if err != nil {
				return nil, err
			}
			uuids = append(uuids, uid)
		}
		query = query.Where("id IN ?", uuids)
	}
	if err := query.Find(&courses).Error; err != nil {
		return nil, err
	}

	var result []*Course
	for _, c := range courses {
		result = append(result, &Course{
			ID:    c.ID.String(),
			Title: c.Title,
			Category: &Category{
				ID:   c.Category.ID.String(),
				Name: c.Category.Name,
			},
		})
	}

	return result, nil
}

// Categories is the resolver for the categories field.
func (r *queryResolver) Categories(ctx context.Context) ([]*Category, error) {
	var categories []models.Category
	if err := r.DB.Find(&categories).Error; err != nil {
		return nil, err
	}

	var result []*Category
	for _, cat := range categories {
		result = append(result, &Category{
			ID:   cat.ID.String(),
			Name: cat.Name,
		})
	}
	return result, nil
}

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type queryResolver struct{ *Resolver }
